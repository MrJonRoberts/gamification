{% extends "base.html" %}

{% block content %}
<h1 class="h4">Syncing Student Images</h1>
<p class="text-muted mb-3">
  Fetching student images from TASS via the server image proxy.
  This may take a moment.
</p>

<div class="alert alert-info" role="alert" id="sync-status">Starting image syncâ€¦</div>
<ul class="small" id="sync-log"></ul>
<input type="hidden" id="csrf-token" value="{{ csrf_token() }}">

<form id="sync-complete-form" action="/courses/" method="get" class="mt-3">
  <button class="btn btn-success" type="submit">Continue to Courses</button>
</form>

<script>
(function () {
  const CSRF = document.getElementById('csrf-token')?.value || '';

  const studentCodes = {{ student_codes | tojson }};
  const statusEl = document.getElementById('sync-status');
  const logEl = document.getElementById('sync-log');
  const imageUrlTemplate = '/courses/proxy-image/';

  const IMAGE_FETCH_TIMEOUT_MS = 8000;
  let successCount = 0;
  let failCount = 0;
  let corsBlocked = false;

  function logLine(message, type) {
    const li = document.createElement('li');
    li.textContent = message;
    li.className = type === 'error' ? 'text-danger' : 'text-success';
    logEl.appendChild(li);
  }

  function isLikelyCorsError(error) {
    if (!(error instanceof TypeError)) {
      return false;
    }

    const message = String(error.message || '').toLowerCase();
    return message.includes('failed to fetch') || message.includes('networkerror');
  }

  async function timeoutFetch(url, timeoutMs) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      return await fetch(url, { signal: controller.signal, credentials: 'include' });
    } finally {
      clearTimeout(timer);
    }
  }

  async function uploadImage(code, blob) {
    const formData = new FormData();
    formData.append('code', code);
    formData.append('image', blob, code + '.jpg');

    const response = await fetch('/courses/student-images', {
      method: 'POST',
      headers: CSRF ? { 'X-CSRFToken': CSRF } : {},
      body: formData,
      credentials: 'same-origin'
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(text || response.statusText);
    }
  }

  async function processOne(code) {
    const imageUrl = imageUrlTemplate + encodeURIComponent(code);
    try {
      const imageResponse = await timeoutFetch(imageUrl, IMAGE_FETCH_TIMEOUT_MS);
      if (!imageResponse.ok) {
        throw new Error('Image fetch failed with status ' + imageResponse.status);
      }

      const blob = await imageResponse.blob();
      if (!blob || blob.size === 0) {
        throw new Error('Image response was empty');
      }

      await uploadImage(code, blob);
      successCount += 1;
      logLine(code + ': image saved', 'success');
      return;
    } catch (error) {
      if (isLikelyCorsError(error)) {
        corsBlocked = true;
        throw new Error('Image proxy request failed.');
      }
      failCount += 1;
      logLine(code + ': skipped (' + error.message + ')', 'error');
    }
  }

  async function run() {
    for (const [index, code] of studentCodes.entries()) {
      try {
        await processOne(code);
      } catch (error) {
        failCount += studentCodes.length - index;
        logLine('Image sync stopped: ' + error.message, 'error');
        break;
      }
    }

    if (corsBlocked) {
      statusEl.className = 'alert alert-warning';
      statusEl.textContent = 'Image sync could not continue because image proxy requests failed. Students were enrolled successfully; you can continue without images.';
      return;
    }

    statusEl.className = failCount ? 'alert alert-warning' : 'alert alert-success';
    statusEl.textContent = `Image sync complete. Saved: ${successCount}. Skipped: ${failCount}.`;
  }

  run();
})();
</script>
{% endblock %}
